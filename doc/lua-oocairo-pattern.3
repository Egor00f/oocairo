.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUA-OOCAIRO-PATTERN 3"
.TH LUA-OOCAIRO-PATTERN 3 "2008-11-07" "1.2" "Lua OO Cairo binding"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
lua-oocairo-pattern \- Cairo pattern objects
.SH "Introduction"
.IX Header "Introduction"
A pattern object is any one of several things that can be used as the
\&\fBsource\fR for a Cairo context, defining what colours and transparencies
will be used for drawing.  These objects can be created explicitly with
the various \f(CW\*(C`pattern_create_*\*(C'\fR functions in the module table (see
\&\fIlua\-oocairo\fR\|(3) for details), or implicitly by calling methods like
\&\f(CW\*(C`cr:set_source_rgb()\*(C'\fR on a context object (see \fIlua\-oocairo\-context\fR\|(3)).
.PP
Pattern objects can be compared with the \f(CW\*(C`==\*(C'\fR operator.  This will compare
the identity of the objects, so different Lua objects which refer to the
same \f(CW\*(C`cairo_pattern_t\*(C'\fR will compare as equal.
.SH "Methods"
.IX Header "Methods"
.IP "pat:add_color_stop_rgb (offset, r, g, b)" 4
.IX Item "pat:add_color_stop_rgb (offset, r, g, b)"
Add a new colour stop to a gradient (either linear or radial, it doesn't
matter).  The offset is a number from zero (the start of the line or the
first circle of the gradient) to one (the end of the line or the second
circle).  The colour values must also be numbers from zero to one.
The alpha level is set to fully transparent.
.Sp
This will throw an exception if called on a pattern which isn't a gradient.
.IP "pat:add_color_stop_rgba (offset, r, g, b, a)" 4
.IX Item "pat:add_color_stop_rgba (offset, r, g, b, a)"
Same as \f(CW\*(C`pat:add_color_stop_rgb()\*(C'\fR above, but the alpha value can be
set to less than one to give some transparency to the gradient.  This
can be used for gradients which fade away into nothing for example.
.IP "pat:get_color_stops ()" 4
.IX Item "pat:get_color_stops ()"
Returns the color stops defined on a linear or radial gradient.
Throws an exception if called on any other type of pattern.
.Sp
The return value will be a table, an array with one entry per color stop.
Each entry will be a table containing five numbers, in the following
order: offset, red, green, blue, alpha.
.IP "pat:get_extend ()" 4
.IX Item "pat:get_extend ()"
Return the current method of extending the pattern beyond its limits.
The return value will be one of the strings accepted by the
\&\f(CW\*(C`pat:set_extend()\*(C'\fR method.
.IP "pat:get_filter ()" 4
.IX Item "pat:get_filter ()"
Return the current filter method, which will be one of the strings
accepted by the \f(CW\*(C`pat:set_filter()\*(C'\fR method.
.IP "pat:get_linear_points ()" 4
.IX Item "pat:get_linear_points ()"
Return the start and end points of a linear gradient as four numbers.
Throws an exception if called on any other type of pattern.
.IP "pat:get_matrix ()" 4
.IX Item "pat:get_matrix ()"
Return the current transformation matrix used for the pattern.
See \fIlua\-oocairo\-matrix\fR\|(3).
.IP "pat:get_radial_circles ()" 4
.IX Item "pat:get_radial_circles ()"
Return the start and end circles of a radial gradient as six numbers.
Throws an exception if called on any other type of pattern.
.IP "pat:get_rgba ()" 4
.IX Item "pat:get_rgba ()"
Return the colour value and alpha level for a solid colour pattern.
Throws an exception for any other type of pattern.  The return values
will be four numbers, in the following order: red, green, blue, alpha.
.IP "pat:get_surface ()" 4
.IX Item "pat:get_surface ()"
Return the surface object (see \fIlua\-oocairo\-surface\fR\|(3)) used for a
surface pattern.  Throws an exception for any other kind of pattern.
.IP "pat:get_type ()" 4
.IX Item "pat:get_type ()"
Returns a string indicating what kind of pattern object this is.
The return value will be one of the following:
.RS 4
.IP "linear" 4
.IX Item "linear"
.PD 0
.IP "radial" 4
.IX Item "radial"
.IP "solid" 4
.IX Item "solid"
.IP "surface" 4
.IX Item "surface"
.RE
.RS 4
.RE
.IP "pat:set_extend (extendtype)" 4
.IX Item "pat:set_extend (extendtype)"
.PD
Set the way in which the pattern should be extended beyond its defined
limits.  The argument must be one of the following strings:
.RS 4
.IP "none" 4
.IX Item "none"
Everything outside the area defined by the pattern is fully transparent.
.IP "repeat" 4
.IX Item "repeat"
Pattern tiled by endlessly repeating it.
.IP "reflect" 4
.IX Item "reflect"
Pattern tiled by reflecting it at its edges.
.IP "pad" 4
.IX Item "pad"
Whatever is at the edge of the pattern is extended outwards.
.RE
.RS 4
.RE
.IP "pat:set_filter (filtertype)" 4
.IX Item "pat:set_filter (filtertype)"
Set the filter method used for picking colours from the pattern when
it is being used to render something.  The argument must be one of the
following strings:
.RS 4
.IP "fast" 4
.IX Item "fast"
Fast interpolation that is likely to be low quality in some cases (but
probably \s-1OK\s0 for a smooth gradient).
.IP "good" 4
.IX Item "good"
Reasonably good quality interpolation.
.IP "best" 4
.IX Item "best"
The highest quality interpolation available, but likely very slow.
.IP "nearest" 4
.IX Item "nearest"
Pick colour of nearest pixel.
.IP "bilinear" 4
.IX Item "bilinear"
Interpolate between pixels.
.IP "gaussian" 4
.IX Item "gaussian"
Gaussian blur, but this isn't implemented yet.
.RE
.RS 4
.RE
.IP "pat:set_matrix (matrix)" 4
.IX Item "pat:set_matrix (matrix)"
Set the transformation matrix used for the pattern, as a table of six
numbers.  See \fIlua\-oocairo\-matrix\fR\|(3).
