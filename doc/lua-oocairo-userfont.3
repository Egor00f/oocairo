.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUA-OOCAIRO-USERFONT 3"
.TH LUA-OOCAIRO-USERFONT 3 "2008-11-07" "1.2" "Lua OO Cairo binding"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
lua-oocairo \- Lua \s-1API\s0 for the Cairo vector graphics library
.SH "Introduction"
.IX Header "Introduction"
User fonts are created by calling the \f(CW\*(C`user_font_face_create\*(C'\fR function
in the main module hash, and passing in a table of callbacks which Cairo
will call when necessary.  The \f(CW\*(C`render_glyph\*(C'\fR callback function must be
supplied, but all the others are optional.
.PP
A user font can be created and set to be used like this:
.PP
.Vb 1
\&    local function render_glyph (...) end
\&
\&    local font = Cairo.user_font_face_create({
\&        init = function () print("initializing") end,
\&        render_glyph = render_glyph,
\&    })
\&    cr:set_font_face(font)
\&    cr:set_font_size(12)
.Ve
.SH "Callbacks"
.IX Header "Callbacks"
The following callbacks can be supplied (the names here being the keys
you should use in the table when creating the font).  The \fIfont\fR
value is always the scaled font object representing the user font at
the size it's being used at.
.IP "init (font, cr, extents)" 4
.IX Item "init (font, cr, extents)"
This is called once, and can be used to set up the font and provide Cairo
with metrics information, by filling in the font \fIextents\fR table supplied.
The extents information is in the same format as that returned by the
\&\f(CW\*(C`font_extents\*(C'\fR method on context objects (see \fIlua\-oocairo\-context\fR\|(3)),
except that all measurements are in font units, which will be scaled
according to the font size.
.Sp
The \fIfont\fR value isn't fully created when this function is called, and
using it is likely to break things.
.Sp
Return values are ignored.
.IP "render_glyph (font, glyph, cr, extents)" 4
.IX Item "render_glyph (font, glyph, cr, extents)"
This callback is required, and will be called for each glyph which needs
to be displayed.  It should draw the glyph using \fIcr\fR, which is a special
Cairo context object which will be scaled to font coordinates.  The
callback must not change the source on \fIcr\fR (so multi-coloured fonts are
out of the question, and rendering bitmap images from another surface needs
to be done with the \f(CW\*(C`mask\*(C'\fR method).
.Sp
The value of the \fIglyph\fR parameter will be the glyph index number of
the glyph which Cairo wants drawn.  This will be whatever is determined
to be appropriate by the other callbacks, or the Unicode codepoint number
as a default.
.Sp
Glyph images are cached, so you can't have a font where each occurrence
of the letter a\*^XXea\*^XX is slightly different, for example.
.Sp
The callback should set the \f(CW\*(C`x_advance\*(C'\fR value in the \fIextents\fR
table to an appropriate value (measured in font coordinates).
Return values are ignored.
.Sp
This example draws all glyphs as a simple triangle shape, except
for the space character (assuming that doesn't end up with some
other glyph index):
.Sp
.Vb 2
\&    local function render_glyph (font, glyph, cr, extents)
\&        extents.x_advance = 1   \-\- distance to move to next glyph
\&
\&        if glyph == 32 then return end  \-\- space, draw nothing
\&
\&        cr:move_to(0, 0)
\&        cr:line_to(1, 0)
\&        cr:line_to(0, 1)
\&        cr:fill()
\&    end
.Ve
.IP "text_to_glyphs (font, text, want_clusters)" 4
.IX Item "text_to_glyphs (font, text, want_clusters)"
Called to translate text into glyphs.  The \fItext\fR parameter is \s-1UTF\-8\s0
encoded text.  The callback should return a table of glyphs which would
be appropriate for rendering it, including appropriate \fIx\fR and \fIy\fR
coordinates for each one, in the same format as accepted by the
\&\f(CW\*(C`show_glyphs\*(C'\fR and \f(CW\*(C`show_text_glyphs\*(C'\fR methods on context objects.
The coordinates should be in font coordinates.
.Sp
If the \fIwant_clusters\fR parameter is true then the font is being used on
a surface which can make use of text cluster information (mapping bytes
in \fItext\fR to glyphs returned).  In this case the callback can optionally
return a second value, an array of pairs in the same format as accepted
by the \f(CW\*(C`show_text_glyphs\*(C'\fR method on context objects.  If \fIwant_clusters\fR
is false then any text clusters information returned will just be
ignored.
.IP "unicode_to_glyph (font, unicode)" 4
.IX Item "unicode_to_glyph (font, unicode)"
Called when there is no \f(CW\*(C`text_to_glyphs\*(C'\fR callback, or it doesn't provide
any glyphs.  The \fIunicode\fR parameter is a Unicode codepoint for a character
being drawn, and the callback should return the glyph index appropriate
for rendering it.  With this simpler callback each Unicode character has to
map to exactly one glyph.
