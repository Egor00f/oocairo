.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUA-OOCAIRO-SURFACE 3"
.TH LUA-OOCAIRO-SURFACE 3 "2008-11-07" "1.2" "Lua OO Cairo binding"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
lua-oocairo-surface \- Cairo surface objects
.SH "Introduction"
.IX Header "Introduction"
All Cairo drawing operations are targeted at a \fBsurface\fR, which represents
a backend writing drawing instructions out to a vector graphics file (\s-1SVG\s0,
\&\s-1PDF\s0, etc.) or drawing to a bitmap image.  Surfaces are created with one of
the top-level constructor functions listed in \fIlua\-oocairo\fR\|(3).
.PP
Surface objects can be compared with the \f(CW\*(C`==\*(C'\fR operator.  This will compare
the identity of the objects, so different Lua objects which refer to the
same \f(CW\*(C`cairo_surface_t\*(C'\fR will compare as equal.
.SH "Methods"
.IX Header "Methods"
The following methods are available on surface objects.
.IP "surf:copy_page ()" 4
.IX Item "surf:copy_page ()"
Same as \f(CW\*(C`surf:show_page()\*(C'\fR, but keeps whatever has been drawn on the current
page for additional drawing on the next page.
.IP "surf:finish ()" 4
.IX Item "surf:finish ()"
Finish any drawing to the surface and disconnect from any external resources
it uses, such as closing a file handle if it's writing output to a file.
No more drawing can be done with this surface after calling this method.
.IP "surf:flush ()" 4
.IX Item "surf:flush ()"
Finish any drawing work currently in progress.
.IP "surf:get_content ()" 4
.IX Item "surf:get_content ()"
Returns a string indicating what kind of content the surface has (colours
and/or transparency).  The return value will be one of the strings
accepted by the \f(CW\*(C`surface_create_similar\*(C'\fR function (see \fIlua\-oocairo\fR\|(3)).
.IP "surf:get_data ()" 4
.IX Item "surf:get_data ()"
Returns the raw data for an image surface as a string, so that you can
pass it to some other library or get the exact colours of each pixel.
Returns nothing for surfaces which aren't image surfaces.
.Sp
See the example program \fIget\-data.lua\fR included with the distribution
for some code to extract the colour values from pixels in the image data.
.Sp
There are actually two values returned from this method, the data itself
and the \fIstride\fR for it.
The stride is the number of bytes of the string used for each
line of the image.  This is at least the width of the image multiplied by
the number of bytes needed for each pixel, although it might be larger
(in which case the extra bytes at the end of each line of pixels should
be ignored).  The length of the data will always be equal to the stride
multipled by the image's height.
.Sp
The data string will contain rows of pixels starting with the top row.
Each row contains the pixels one after another, with no padding in between,
starting from the left hand side.
.Sp
The way individual pixels are stored depends on the image format, which
can be queried with the \f(CW\*(C`surf:get_format()\*(C'\fR method.  For colour images,
that is ones with a format of \f(CW\*(C`rgb24\*(C'\fR or \f(CW\*(C`argb32\*(C'\fR, each pixel will be
four bytes in size.  The alpha, red, green, and blue components will be
in the order given by the string \f(CW\*(C`Cairo.BYTE_ORDER\*(C'\fR.  On \f(CW\*(C`rgb24\*(C'\fR
images the alpha value should be ignored, although it will still be present
(that is, the pixels will still be stored in 32\ bits each, not 24\ bits).
.Sp
If the format is \f(CW\*(C`a8\*(C'\fR then each pixel will be one byte.  The \f(CW\*(C`a1\*(C'\fR format
stores each pixel as one bit, in groups of 32 bits ordered according to the
endianness of the platform (so if the last value returned from the method
is \f(CW\*(C`argb\*(C'\fR then the first pixel will be the most significant bit of the 32
bits, otherwise the reverse).
.IP "surf:get_device_offset ()" 4
.IX Item "surf:get_device_offset ()"
Returns two numbers, whichever ones were set with \f(CW\*(C`surf:set_device_offset()\*(C'\fR.
.IP "surf:get_eps ()" 4
.IX Item "surf:get_eps ()"
Returns a boolean value matching whatever was last set with
\&\f(CW\*(C`surf:set_eps()\*(C'\fR, or throws an exception if \fIsurf\fR is not a PostScript
surface.
.IP "surf:get_fallback_resolution ()" 4
.IX Item "surf:get_fallback_resolution ()"
Returns two numbers, the values set by \f(CW\*(C`surf:set_fallback_resolution()\*(C'\fR.
Only available with Cairo\ 1.8 or better.
.IP "surf:get_font_options ()" 4
.IX Item "surf:get_font_options ()"
Returns a new font options object containing the preferred options for
rendering text on this surface.  These options are used automatically
when rendering text, so can usually be ignored, but might be useful if
you want to render some text to an image internally and then present it
on a surface on screen, in a widget of some sort.
.Sp
See \fIlua\-oocairo\-fontopt\fR\|(3) for more about font options objects.
.IP "surf:get_format ()" 4
.IX Item "surf:get_format ()"
Return the pixel format for an image surface.  Throws an exception for
other surface types.  The return value will be one of the strings accepted
by the \f(CW\*(C`image_surface_create\*(C'\fR function (see \fIlua\-oocairo\fR\|(3)).
.IP "surf:get_gdk_pixbuf ()" 4
.IX Item "surf:get_gdk_pixbuf ()"
Creates a GdkPixbuf object containing the image currently held on an image
surface.  The return value is suitable for use with the Lua-Gnome library,
for example as an icon.  See the example program \fIgtk\-drawing.lua\fR for
an example showing that use.
.Sp
Must be called on an image surface, otherwise it throws an exception.  Also,
it currently only supports the \f(CW\*(C`rgb24\*(C'\fR adn \f(CW\*(C`argb32\*(C'\fR formats.
.Sp
Requires the Lua-Gnome package to have been installed and the \f(CW\*(C`gtk\*(C'\fR module
to be loaded.
.IP "surf:get_height ()" 4
.IX Item "surf:get_height ()"
Returns the height in pixels of an image surface, or throws an exception
for other types.
.IP "surf:get_type ()" 4
.IX Item "surf:get_type ()"
Returns a string indicating what type of surface object \fIsurf\fR is.
The value will be one of the following:
.RS 4
.IP "image" 4
.IX Item "image"
A bitmap image stored in a memory buffer.
.IP "pdf" 4
.IX Item "pdf"
Vector drawing into a Adobe(tm) \s-1PDF\s0 file.
.IP "ps" 4
.IX Item "ps"
Vector drawing into a PostScript file.
.IP "svg" 4
.IX Item "svg"
Vector drawing into an \s-1SVG\s0 file.
.IP "xlib" 4
.IX Item "xlib"
An X window in a graphical user interface such as Gtk+.
.RE
.RS 4
.Sp
Other values are theoretically possible, but there isn't yet any way to
create them with this binding of Cairo.
.RE
.IP "surf:get_width ()" 4
.IX Item "surf:get_width ()"
Returns the width in pixels of an image surface, or throws an exception
for other types.
.IP "surf:has_show_text_glyphs ()" 4
.IX Item "surf:has_show_text_glyphs ()"
Returns true if this surface can use text cluster information to improve
the quality of text information in the output.  If true then it may be
beneficial to use the \f(CW\*(C`show_text_glyphs\*(C'\fR method on a context object instead
of the \f(CW\*(C`show_glyphs\*(C'\fR method, otherwise that will make no difference.
.Sp
Only available with Cairo\ 1.8 or better.
.IP "surf:set_device_offset (x, y)" 4
.IX Item "surf:set_device_offset (x, y)"
Set two numbers which are added to the \fIx\fR and \fIy\fR coordinates used for
drawing after the current transformation matrix has been applied.
.IP "surf:set_eps (eps)" 4
.IX Item "surf:set_eps (eps)"
On a PostScript surface this sets whether the output should be encapsulated
PostScript or not.  The value of \fIeps\fR is interpreted as boolean.
Throws an exception if \fIsurf\fR is not a PostScript surface.
.IP "surf:set_fallback_resolution (x, y)" 4
.IX Item "surf:set_fallback_resolution (x, y)"
Set the resolution at which vector graphics are rendered to bitmaps when
drawing something on a vector-based surface type which can't be directly
represented.  Has no effect on surfaces where the output is bitmapped
anyway.  The values of \fIx\fR and \fIy\fR must be numbers.
.IP "surf:set_size (width, height)" 4
.IX Item "surf:set_size (width, height)"
Set the size in points of the next page of PostScript or \s-1PDF\s0 output.
This should be called before any drawing has been done on the new page
(probably just after creating the surface or just after the last
\&\f(CW\*(C`surf:show_page()\*(C'\fR call).  The values of \fIwidth\fR and \fIheight\fR should
be numbers.  Throws an exception if \fIsurf\fR isn't a PostScript or \s-1PDF\s0
surface.
.IP "surf:show_page ()" 4
.IX Item "surf:show_page ()"
Starts a new page on surfaces which support that (such as \s-1PDF\s0 and PostScript).
.IP "surf:write_to_png (file/filename)" 4
.IX Item "surf:write_to_png (file/filename)"
Write the bitmap data from a surface out to the specified file in \s-1PNG\s0
format.  The argument can be a filename or file handle.
